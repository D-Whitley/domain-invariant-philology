import React, { useState, useEffect } from 'react';
import { Play, Pause, RotateCcw, ZoomIn, ZoomOut } from 'lucide-react';

const RecursionExplorer = () => {
  const [depth, setDepth] = useState(0);
  const [maxDepth, setMaxDepth] = useState(7);
  const [isAnimating, setIsAnimating] = useState(false);
  const [scale, setScale] = useState(1);

  useEffect(() => {
    let interval;
    if (isAnimating) {
      interval = setInterval(() => {
        setDepth(d => {
          if (d >= maxDepth) {
            setIsAnimating(false);
            return maxDepth;
          }
          return d + 0.1;
        });
      }, 100);
    }
    return () => clearInterval(interval);
  }, [isAnimating, maxDepth]);

  const reset = () => {
    setDepth(0);
    setIsAnimating(false);
    setScale(1);
  };

  // Fractal Domain: Sierpinski Triangle
  const FractalDomain = () => {
    const drawSierpinski = (ctx, x, y, size, depth) => {
      if (depth === 0) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + size, y);
        ctx.lineTo(x + size/2, y - size * Math.sqrt(3)/2);
        ctx.closePath();
        ctx.fill();
        return;
      }
      
      const halfSize = size / 2;
      drawSierpinski(ctx, x, y, halfSize, depth - 1);
      drawSierpinski(ctx, x + halfSize, y, halfSize, depth - 1);
      drawSierpinski(ctx, x + size/4, y - halfSize * Math.sqrt(3)/2, halfSize, depth - 1);
    };

    useEffect(() => {
      const canvas = document.getElementById('fractal-canvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, 400, 350);
      
      ctx.fillStyle = '#8b5cf6';
      ctx.globalAlpha = 0.7;
      drawSierpinski(ctx, 50, 320, 300, Math.floor(depth));
    }, [depth]);

    return (
      <div className="p-6 bg-gradient-to-br from-purple-50 to-violet-50 rounded-lg">
        <h3 className="font-bold text-lg mb-4 text-purple-900">Geometric Self-Similarity</h3>
        <div className="relative">
          <canvas 
            id="fractal-canvas" 
            width="400" 
            height="350"
            className="w-full border border-purple-200 rounded bg-white"
          />
          <div className="absolute top-2 right-2 bg-purple-900 bg-opacity-80 text-white text-xs px-2 py-1 rounded">
            Depth: {Math.floor(depth)}
          </div>
        </div>
        <div className="mt-2 text-xs text-purple-700">
          Sierpinski Triangle • Each triangle contains 3 copies of itself at half scale
        </div>
      </div>
    );
  };

  // Musical Domain: Canon/Fugue structure
  const MusicalDomain = () => {
    const voices = [
      { delay: 0, color: '#3b82f6', name: 'Voice 1' },
      { delay: 2, color: '#8b5cf6', name: 'Voice 2' },
      { delay: 4, color: '#ec4899', name: 'Voice 3' },
      { delay: 6, color: '#f59e0b', name: 'Voice 4' },
    ];

    const getVoiceHeight = (voice, time) => {
      const localTime = time - voice.delay;
      if (localTime < 0) return null;
      
      // Theme repeats at different scales
      const phase = (localTime % 4) / 4;
      const octave = Math.floor(localTime / 4);
      const baseHeight = Math.sin(phase * Math.PI * 2) * 30;
      
      // Each iteration gets more compressed (faster)
      const compression = Math.pow(0.8, octave);
      return baseHeight * compression + 80;
    };

    return (
      <div className="p-6 bg-gradient-to-br from-blue-50 to-indigo-50 rounded-lg">
        <h3 className="font-bold text-lg mb-4 text-blue-900">Canonical Recursion</h3>
        <div className="h-48 bg-white border border-blue-200 rounded p-4">
          <svg viewBox="0 0 400 160" className="w-full h-full">
            {/* Time grid */}
            {[0, 1, 2, 3, 4, 5, 6, 7].map(i => (
              <line
                key={i}
                x1={i * 50}
                y1="0"
                x2={i * 50}
                y2="160"
                stroke="#e0e7ff"
                strokeWidth="1"
              />
            ))}
            
            {/* Musical staff lines */}
            {[40, 60, 80, 100, 120].map((y, i) => (
              <line key={i} x1="0" y1={y} x2="400" y2={y} stroke="#e0e7ff" strokeWidth="1" />
            ))}

            {/* Voices */}
            {voices.map((voice, idx) => {
              if (depth < voice.delay) return null;
              
              const points = [];
              for (let t = voice.delay; t <= depth && t <= maxDepth; t += 0.2) {
                const h = getVoiceHeight(voice, t);
                if (h !== null) {
                  points.push(`${t * 50},${h}`);
                }
              }
              
              return (
                <g key={idx}>
                  <polyline
                    points={points.join(' ')}
                    fill="none"
                    stroke={voice.color}
                    strokeWidth="2"
                    opacity="0.8"
                  />
                  {depth >= voice.delay && (
                    <circle
                      cx={depth * 50}
                      cy={getVoiceHeight(voice, depth) || 80}
                      r="4"
                      fill={voice.color}
                    />
                  )}
                </g>
              );
            })}
          </svg>
        </div>
        <div className="mt-2 text-xs text-blue-700">
          Fugue structure • Each voice enters playing the same theme at different times and scales
        </div>
      </div>
    );
  };

  // Narrative Domain: Story within story (mise en abyme)
  const NarrativeDomain = () => {
    const stories = [
      { level: 0, title: "Reader reading a book...", color: "bg-green-600" },
      { level: 1, title: "...about a character reading a story...", color: "bg-green-500" },
      { level: 2, title: "...about someone telling a tale...", color: "bg-green-400" },
      { level: 3, title: "...featuring a narrator describing...", color: "bg-green-300" },
      { level: 4, title: "...a manuscript containing...", color: "bg-green-200" },
      { level: 5, title: "...a legend of...", color: "bg-green-100" },
      { level: 6, title: "...infinite regress", color: "bg-green-50" },
    ];

    const currentDepth = Math.floor(depth);

    return (
      <div className="p-6 bg-gradient-to-br from-green-50 to-emerald-50 rounded-lg">
        <h3 className="font-bold text-lg mb-4 text-green-900">Nested Narratives</h3>
        <div className="h-48 flex items-center justify-center">
          <div className="relative w-full max-w-md">
            {stories.slice(0, currentDepth + 1).map((story, idx) => {
              const offset = idx * 20;
              const size = 100 - idx * 12;
              
              return (
                <div
                  key={idx}
                  className={`absolute ${story.color} border-2 border-green-800 rounded-lg p-3 transition-all duration-300`}
                  style={{
                    left: `${offset}px`,
                    top: `${offset}px`,
                    width: `${size}%`,
                    opacity: 1 - idx * 0.1,
                    zIndex: 10 - idx,
                  }}
                >
                  <div className="text-xs font-semibold text-green-900 truncate">
                    Level {idx}: {story.title}
                  </div>
                </div>
              );
            })}
          </div>
        </div>
        <div className="mt-2 text-xs text-green-700">
          Mise en abyme • Stories contain stories contain stories (1001 Nights, Borges)
        </div>
      </div>
    );
  };

  // Chemical Domain: Autocatalytic cycle
  const ChemicalDomain = () => {
    const nodes = [];
    const currentDepth = Math.floor(depth);
    
    // Build autocatalytic network
    const angleStep = (Math.PI * 2) / Math.max(currentDepth + 1, 3);
    for (let i = 0; i <= currentDepth; i++) {
      const angle = i * angleStep - Math.PI / 2;
      nodes.push({
        x: 200 + Math.cos(angle) * 80,
        y: 120 + Math.sin(angle) * 80,
        label: `A${i}`,
      });
    }

    return (
      <div className="p-6 bg-gradient-to-br from-orange-50 to-red-50 rounded-lg">
        <h3 className="font-bold text-lg mb-4 text-orange-900">Autocatalytic Network</h3>
        <div className="h-48 bg-white border border-orange-200 rounded">
          <svg viewBox="0 0 400 240" className="w-full h-full">
            {/* Draw connections (each molecule catalyzes next) */}
            {nodes.map((node, i) => {
              const nextNode = nodes[(i + 1) % nodes.length];
              if (!nextNode) return null;
              
              return (
                <g key={i}>
                  <line
                    x1={node.x}
                    y1={node.y}
                    x2={nextNode.x}
                    y2={nextNode.y}
                    stroke="#f97316"
                    strokeWidth="2"
                    markerEnd="url(#arrowhead)"
                    opacity="0.6"
                  />
                </g>
              );
            })}
            
            {/* Arrow marker definition */}
            <defs>
              <marker
                id="arrowhead"
                markerWidth="10"
                markerHeight="10"
                refX="9"
                refY="3"
                orient="auto"
              >
                <polygon points="0 0, 10 3, 0 6" fill="#f97316" />
              </marker>
            </defs>
            
            {/* Draw nodes */}
            {nodes.map((node, i) => (
              <g key={i}>
                <circle
                  cx={node.x}
                  cy={node.y}
                  r="20"
                  fill="#fb923c"
                  stroke="#ea580c"
                  strokeWidth="2"
                />
                <text
                  x={node.x}
                  y={node.y + 5}
                  textAnchor="middle"
                  className="text-sm font-semibold fill-white"
                >
                  {node.label}
                </text>
              </g>
            ))}
            
            {/* Center self-reference annotation */}
            <text x="200" y="120" textAnchor="middle" className="text-xs fill-orange-700 font-semibold">
              {currentDepth > 2 ? "Self-sustaining cycle" : "Building..."}
            </text>
          </svg>
        </div>
        <div className="mt-2 text-xs text-orange-700">
          Each molecule catalyzes production of the next • System bootstraps itself into existence
        </div>
      </div>
    );
  };

  // Code Domain: Recursive function visualization
  const CodeDomain = () => {
    const callStack = [];
    const maxCalls = Math.min(Math.floor(depth) + 1, 7);
    
    for (let i = 0; i < maxCalls; i++) {
      callStack.push({
        level: i,
        n: maxDepth - i,
        indent: i * 30,
      });
    }

    return (
      <div className="p-6 bg-gradient-to-br from-slate-50 to-gray-50 rounded-lg">
        <h3 className="font-bold text-lg mb-4 text-slate-900">Computational Self-Reference</h3>
        <div className="h-48 bg-slate-900 rounded p-4 overflow-hidden font-mono text-xs">
          <div className="text-green-400 mb-2">function factorial(n) {"{"}</div>
          <div className="text-green-400 mb-4 ml-4">
            if (n ≤ 1) return 1;
            <br />
            return n * factorial(n - 1);
          </div>
          <div className="text-green-400 mb-4">{"}"}</div>
          
          <div className="text-yellow-400 mb-2">// Call stack:</div>
          {callStack.map((call, i) => (
            <div
              key={i}
              className="text-cyan-400 transition-all duration-300"
              style={{ 
                marginLeft: `${call.indent}px`,
                opacity: 1 - i * 0.1 
              }}
            >
              factorial({call.n}) {i === callStack.length - 1 && call.n <= 1 ? '→ 1' : '→ ...'}
            </div>
          ))}
          
          {maxCalls > 3 && (
            <div className="text-purple-400 mt-4" style={{ marginLeft: `${(maxCalls - 1) * 30}px` }}>
              // Unwinding...
            </div>
          )}
        </div>
        <div className="mt-2 text-xs text-slate-700">
          Function calls itself • Each invocation creates deeper context until base case
        </div>
      </div>
    );
  };

  // THE INVARIANT - extracted structure
  const InvariantStructure = () => {
    const currentDepth = Math.floor(depth);
    
    return (
      <div className="col-span-2 p-6 bg-gradient-to-br from-gray-900 to-slate-800 rounded-lg text-white">
        <h3 className="font-bold text-lg mb-4">The Invariant Structure of Recursion</h3>
        <div className="grid grid-cols-2 gap-6">
          <div>
            <h4 className="text-sm font-semibold mb-2 text-gray-300">Self-Reference Operator</h4>
            <div className="font-mono text-xs bg-black bg-opacity-50 p-3 rounded">
              <div>R(x) = F(x, R(x))</div>
              <div className="mt-2 text-gray-400">Fixed point: x = F(x, x)</div>
              <div className="mt-3 text-yellow-300">
                Current depth: {currentDepth}
              </div>
              <div className="text-cyan-300">
                Complexity: O(b^d) where b=branching, d=depth
              </div>
            </div>
          </div>
          
          <div>
            <h4 className="text-sm font-semibold mb-2 text-gray-300">Scale Invariance</h4>
            <svg viewBox="0 0 200 120" className="w-full h-24 bg-black bg-opacity-50 rounded">
              {/* Logarithmic spiral representing scale invariance */}
              <path
                d={Array.from({ length: 100 }, (_, i) => {
                  const t = i / 20;
                  const r = 5 * Math.exp(t * 0.2);
                  const x = 100 + r * Math.cos(t);
                  const y = 60 + r * Math.sin(t);
                  return `${i === 0 ? 'M' : 'L'} ${x},${y}`;
                }).join(' ')}
                fill="none"
                stroke="#fbbf24"
                strokeWidth="2"
              />
              {/* Mark current depth */}
              {depth > 0 && (
                <circle
                  cx={100 + 5 * Math.exp(depth * 0.2 / maxDepth * 5) * Math.cos(depth * 0.2 / maxDepth * 5)}
                  cy={60 + 5 * Math.exp(depth * 0.2 / maxDepth * 5) * Math.sin(depth * 0.2 / maxDepth * 5)}
                  r="4"
                  fill="#ef4444"
                />
              )}
              <text x="100" y="115" textAnchor="middle" className="text-xs fill-gray-400">
                Same pattern at all scales
              </text>
            </svg>
          </div>

          <div className="col-span-2">
            <h4 className="text-sm font-semibold mb-2 text-gray-300">Topological Features</h4>
            <div className="grid grid-cols-4 gap-4 text-xs">
              <div className="bg-black bg-opacity-50 p-3 rounded">
                <div className="text-gray-400">Structure</div>
                <div className="text-xl font-bold text-cyan-400">Fractal</div>
                <div className="text-gray-500">Self-similar</div>
              </div>
              <div className="bg-black bg-opacity-50 p-3 rounded">
                <div className="text-gray-400">Dimension</div>
                <div className="text-xl font-bold text-green-400">
                  {currentDepth === 0 ? '0D' : `${currentDepth}D`}
                </div>
                <div className="text-gray-500">Grows with depth</div>
              </div>
              <div className="bg-black bg-opacity-50 p-3 rounded">
                <div className="text-gray-400">Symmetry</div>
                <div className="text-xl font-bold text-purple-400">Scale</div>
                <div className="text-gray-500">Zoom invariant</div>
              </div>
              <div className="bg-black bg-opacity-50 p-3 rounded">
                <div className="text-gray-400">Termination</div>
                <div className="text-xl font-bold text-orange-400">
                  {currentDepth >= maxDepth ? 'Base' : '∞'}
                </div>
                <div className="text-gray-500">Needs boundary</div>
              </div>
            </div>
          </div>

          <div className="col-span-2">
            <h4 className="text-sm font-semibold mb-2 text-gray-300">Information Dynamics</h4>
            <div className="bg-black bg-opacity-50 p-3 rounded">
              <div className="grid grid-cols-2 gap-4 text-xs">
                <div>
                  <div className="text-yellow-300 font-semibold mb-1">Compression</div>
                  <div className="text-gray-300">
                    Infinite complexity from finite rule: F(F(F(...)))
                  </div>
                  <div className="text-cyan-400 mt-1">
                    Kolmogorov complexity ≈ |Rule| + log(depth)
                  </div>
                </div>
                <div>
                  <div className="text-yellow-300 font-semibold mb-1">Expansion</div>
                  <div className="text-gray-300">
                    Each level multiplies state space
                  </div>
                  <div className="text-cyan-400 mt-1">
                    States ≈ branching_factor ^ depth
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div className="col-span-2 mt-4 p-4 bg-yellow-900 bg-opacity-30 border border-yellow-600 rounded">
            <div className="text-sm font-semibold text-yellow-200 mb-2">Observed Invariants:</div>
            <ul className="text-xs space-y-1 text-yellow-100">
              <li>• Self-reference: output becomes input (strange loop)</li>
              <li>• Scale invariance: same structure at all magnifications</li>
              <li>• Infinite regress: no natural stopping point (requires external base case)</li>
              <li>• Exponential growth: complexity explodes with depth</li>
              <li>• Dimensional expansion: each recursion adds a dimension to state space</li>
              <li>• Compression paradox: infinite pattern from finite specification</li>
              <li>• Context stacking: each level preserves all previous contexts</li>
            </ul>
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="w-full max-w-7xl mx-auto p-6 bg-gray-50">
      <div className="mb-6">
        <h1 className="text-3xl font-bold mb-2 text-gray-900">
          Universal Semantic Structure: Recursion
        </h1>
        <p className="text-gray-600 text-sm">
          Exploring self-reference, scale invariance, and infinite regress across domains
        </p>
      </div>

      <div className="mb-6 flex gap-4 items-center bg-white p-4 rounded-lg shadow">
        <button
          onClick={() => setIsAnimating(!isAnimating)}
          className="p-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition"
        >
          {isAnimating ? <Pause size={24} /> : <Play size={24} />}
        </button>
        <button
          onClick={reset}
          className="p-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition"
        >
          <RotateCcw size={24} />
        </button>
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-2">
            <span className="text-sm font-medium text-gray-700">Max Depth:</span>
            <input
              type="range"
              min="3"
              max="10"
              value={maxDepth}
              onChange={(e) => setMaxDepth(Number(e.target.value))}
              className="flex-1"
            />
            <span className="text-sm font-mono text-gray-700 w-8">{maxDepth}</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-3">
            <div
              className="bg-blue-600 h-3 rounded-full transition-all duration-100"
              style={{ width: `${(depth / maxDepth) * 100}%` }}
            />
          </div>
        </div>
        <div className="text-sm font-mono text-gray-700">
          depth = {depth.toFixed(1)} / {maxDepth}
        </div>
      </div>

      <div className="grid grid-cols-3 gap-4 mb-4">
        <FractalDomain />
        <MusicalDomain />
        <NarrativeDomain />
        <ChemicalDomain />
        <CodeDomain />
        <InvariantStructure />
      </div>

      <div className="mt-6 p-6 bg-white rounded-lg shadow">
        <h3 className="font-bold text-lg mb-3">What Do We See?</h3>
        <div className="text-sm text-gray-700 space-y-3">
          <p>
            <strong>Fundamentally Different from Tension→Resolution:</strong> Where T→R was a <em>path</em> through 
            state space (3 phases, endpoint), recursion is a <em>fractal expansion</em> (infinite potential depth, 
            no natural endpoint).
          </p>
          <p>
            <strong>Yet Structurally Invariant:</strong> Despite different topology, the same computational pattern 
            emerges: (1) self-reference loop, (2) scale invariance, (3) context preservation, 
            (4) exponential state-space growth.
          </p>
          <p>
            <strong>The Compression Paradox:</strong> Recursion encodes infinite complexity in a finite rule. 
            This is fundamentally different from T→R's information decrease. Here, information <em>expands</em> 
            with each iteration, yet the <em>description</em> stays constant: F(F(F(...))).
          </p>
          <p>
            <strong>Dimensional Growth:</strong> Unlike T→R which moves from high-dim → low-dim, recursion 
            <em>adds dimensions</em>. Each recursive level is a new axis in state space. The manifold 
            itself is growing.
          </p>
          <p className="text-blue-700 font-semibold pt-2 border-t border-gray-200">
            → This reveals something crucial: <strong>semantic primitives have different topologies</strong> 
            (paths vs fractals vs cycles), but they share <em>geometric properties</em>: symmetries, 
            dimensionality transforms, attractor structure, information flow direction.
          </p>
          <p className="text-purple-700 font-semibold">
            → The universal semantics isn't "everything is the same shape" — it's "everything is a 
            <em>transformation in the same space</em>." Different primitives are different <em>operators</em> 
            on the semantic manifold.
          </p>
        </div>
      </div>
    </div>
  );
};

export default RecursionExplorer;
